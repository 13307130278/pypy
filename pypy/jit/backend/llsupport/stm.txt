stm support
-----------    

Any SETFIELD_GC, SETARRAYITEM_GC, SETINTERIORFIELD_GC must be done on a
local object.  The operation that forces an object p1 to be local is
COND_CALL_GC_WB(p1, 0, descr=wbdescr).  When we have stm, this
COND_CALL_GC_WB is a bit special because if p1 is global, it *replaces*
its value with the local copy (by changing the register's value and
patching the stack location if any).  It's still conceptually the same
object, but the pointer is different.

GETFIELD_GC & friends are more complex.

The fast case is if we also see a write to the same object.  In this
case we know that the object will have a local copy anyway, even if the
write is done after the read (we ignore the rare case that a guard may
fail inbetween).  So in this case we use the same rule as for
SETFIELD_GC.

The slow case is where we need to read the global object in-place.
We insert STM_READ_BEFORE() before and STM_READ_AFTER() after, and
between these two operations there can be only (one or several) reads
from one object: GETFIELD_GC, GETARRAYITEM_GC, GETINTERIORFIELD_GC,
COPYSTRCONTENT, COPYUNICODECONTENT.  We need to be careful here because
STM_READ_AFTER might jump back to STM_READ_BEFORE.  So we must somehow
precompute how many spills we will need to do, and do them before
entering the STM_READ_BEFORE.  As a first approximation, we can ensure
that all registers are spilled before STM_READ_BEFORE.

STM_READ_BEFORE():

    - if (p->flags & GCFLAG_GLOBAL == 0), ovt = p->version

    - else ovt = (call a helper function "ll_stm_read_before")

ll_stm_read_before():

    - if ((p->flags & GCFLAG_WAS_COPIED) != 0 && local_copy_exists(p))
        replace p with its local copy in the caller (register and stack)
        return p->version

    - load the thread-local global d = thread_descriptor

    - ovt = p->version

    - if (ovt is locked or newer than d->start_time)
        call handle_spinloop_or_validation(ovt)
        jump back to reading 'ovt' above

    - if (!is_inevitable(d))
        oreclist_insert_if_not_already(d->reads, p)

    - return ovt

STM_READ_AFTER():

    - if (p->version != ovt)
        jump back to STM_READ_BEFORE
